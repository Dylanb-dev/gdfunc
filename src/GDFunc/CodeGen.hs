{-# LANGUAGE LambdaCase #-}

module GDFunc.CodeGen
    ( generateC
    , compileToCFile
    , CompileOptions(..)
    , defaultOptions
    ) where

import GDFunc.Parser
import qualified GDFunc.Parser as P
import Data.List (intercalate)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Control.Monad.State
import Control.Monad.Writer
import Control.Monad (forM_, zipWithM_)  -- Add this import
import Data.Char (isAlphaNum)

-- Compilation options
data CompileOptions = CompileOptions
    { optOutputFile :: FilePath
    , optOptimization :: Int  -- 0-3, like gcc -O0 to -O3
    , optDebug :: Bool
    , optIncludePaths :: [FilePath]
    } deriving (Show)

defaultOptions :: CompileOptions
defaultOptions = CompileOptions
    { optOutputFile = "output.c"
    , optOptimization = 2
    , optDebug = False
    , optIncludePaths = []
    }

-- Code generation state
data CodeGenState = CodeGenState
    { nextVarId :: Int
    , varBindings :: Map String String  -- GDFunc var -> C var
    , generatedDecls :: [String]
    , stringLiterals :: Map String Int
    } deriving (Show)

emptyState :: CodeGenState
emptyState = CodeGenState
    { nextVarId = 0
    , varBindings = Map.empty
    , generatedDecls = []
    , stringLiterals = Map.empty
    }

type CodeGen a = StateT CodeGenState (Writer [String]) a

-- Emit a line of C code
emit :: String -> CodeGen ()
emit line = tell [line]

-- Generate fresh C variable name
freshVar :: String -> CodeGen String
freshVar prefix = do
    st <- get
    let vid = nextVarId st
    put st { nextVarId = vid + 1 }
    return $ sanitizeName prefix ++ "_" ++ show vid

-- Sanitize GDFunc identifier to valid C identifier
sanitizeName :: String -> String
sanitizeName name = 
    let cleaned = map (\c -> if isAlphaNum c then c else '_') name
    in if null cleaned then "var" else cleaned

-- Add variable binding
bindVar :: String -> String -> CodeGen ()
bindVar gdfuncVar cVar = do
    st <- get
    put st { varBindings = Map.insert gdfuncVar cVar (varBindings st) }

-- Look up variable binding
lookupVar :: String -> CodeGen String
lookupVar name = do
    st <- get
    case Map.lookup name (varBindings st) of
        Just cVar -> return cVar
        Nothing -> return $ sanitizeName name  -- Use sanitized name if not bound

-- Generate C code for a module
generateC :: Module -> String
generateC mod = 
    let (_, output) = runWriter (evalStateT (genModule mod) emptyState)
    in unlines output

-- Generate module
genModule :: Module -> CodeGen ()
genModule (Module name _ imports decls) = do
    -- C header
    emit "// Generated by GDFunc compiler"
    emit "#include <stdio.h>"
    emit "#include <stdlib.h>"
    emit "#include <string.h>"
    emit "#include <stdint.h>"
    emit ""
    
    -- Runtime support
    emitRuntimeSupport
    
    -- Forward declarations
    emit "// Forward declarations"
    mapM_ genDeclForward decls
    emit ""
    
    -- Generate declarations
    emit "// Function definitions"
    mapM_ genDeclaration decls
    emit ""
    
    -- Main entry point - call the 'main' function if it exists
    emit "// Entry point"
    emit "int main(int argc, char** argv) {"
    
    -- Check if there's a 'main' function defined
    let hasMain = any isMainFunction decls
    if hasMain
        then do
            emit "    int result = main(0);  // Call GDFunc main with dummy arg"
            emit "    printf(\"%d\\n\", result);  // Print result"
            emit "    return 0;"
        else do
            emit "    printf(\"No main function defined\\n\");"
            emit "    return 0;"
    emit "}"
  where
    isMainFunction (FunctionDecl "main" _ _) = True
    isMainFunction _ = False
-- Emit runtime support functions
emitRuntimeSupport :: CodeGen ()
emitRuntimeSupport = do
    emit "// Runtime support"
    emit ""
    emit "// List structure"
    emit "typedef struct List {"
    emit "    void* head;"
    emit "    struct List* tail;"
    emit "    int is_nil;"
    emit "} List;"
    emit ""
    emit "List* nil() {"
    emit "    List* l = malloc(sizeof(List));"
    emit "    l->is_nil = 1;"
    emit "    return l;"
    emit "}"
    emit ""
    emit "List* cons(void* head, List* tail) {"
    emit "    List* l = malloc(sizeof(List));"
    emit "    l->head = head;"
    emit "    l->tail = tail;"
    emit "    l->is_nil = 0;"
    emit "    return l;"
    emit "}"
    emit ""
    emit "// Linear resource tracking (placeholder)"
    emit "void consume_linear(void* ptr) {"
    emit "    // In a full implementation, this would enforce single use"
    emit "    // For now, just a marker"
    emit "}"
    emit ""

-- Generate forward declaration
genDeclForward :: Declaration -> CodeGen ()
genDeclForward (FunctionDecl name patterns _) = do
    let cName = sanitizeName name
    let arity = length patterns
    if arity == 0
        then emit $ "int " ++ cName ++ "();"
        else emit $ "int " ++ cName ++ "(int " ++ intercalate ", int " (map (\i -> "arg" ++ show i) [0..arity-1]) ++ ");"
genDeclForward _ = return ()

-- Generate declaration
genDeclaration :: Declaration -> CodeGen ()
genDeclaration (TypeAnnotation name typ) = do
    -- Type annotations are handled by type checker, emit as comment
    emit $ "// " ++ name ++ " : " ++ show typ

genDeclaration (FunctionDecl name patterns body) = do
    let cName = sanitizeName name
    let arity = length patterns
    
    -- Function signature
    if arity == 0
        then emit $ "int " ++ cName ++ "() {"
        else do
            let params = intercalate ", " (map (\i -> "int arg" ++ show i) [0..arity-1])
            emit $ "int " ++ cName ++ "(" ++ params ++ ") {"
    
    -- Bind pattern variables to parameters
    zipWithM_ bindPattern patterns [0..]
    
    -- Generate function body
    resultVar <- genExpr body
    emit $ "    return " ++ resultVar ++ ";"
    emit "}"
    emit ""

genDeclaration (TypeDecl name vars constructors) = do
    -- Emit as comment for now
    emit $ "// type " ++ name ++ " = ..."

genDeclaration (TypeAlias name vars typ) = do
    emit $ "// type alias " ++ name ++ " = ..."

genDeclaration (SharedTypeDecl name vars constructors) = do
    -- Emit as comment for now
    emit $ "// type shared " ++ name ++ " = ..."

genDeclaration (SharedTypeAlias name vars typ) = do
    emit $ "// type shared alias " ++ name ++ " = ..."

-- Bind pattern to parameter
bindPattern :: Pattern -> Int -> CodeGen ()
bindPattern (PVar varName) idx = do
    let paramName = "arg" ++ show idx
    bindVar varName paramName
bindPattern (PBorrow pattern) idx = do
    -- Recursively bind the inner pattern
    -- For borrowed patterns, we bind but don't consume
    bindPattern pattern idx
    -- Could emit borrow tracking here
    emit "    // Borrowed parameter"
bindPattern _ _ = return ()  -- Other patterns not yet supported

-- Generate expression, returns the C variable holding the result
genExpr :: Expr -> CodeGen String

genExpr (EVar name) = lookupVar name

genExpr (EBorrow expr) = do
    -- Generate code for the borrowed expression
    exprVar <- genExpr expr
    -- Borrowing doesn't consume in C (non-consuming reference)
    -- In a full implementation, this would track that the value is borrowed
    emit $ "    // Borrowed reference to " ++ exprVar
    return exprVar

genExpr (EInt n) = return $ show n

genExpr (EFloat f) = return $ show f

genExpr (EChar c) = return $ show (fromEnum c)

genExpr (EString s) = do
    st <- get
    let literals = stringLiterals st
    case Map.lookup s literals of
        Just idx -> return $ "str_" ++ show idx
        Nothing -> do
            let idx = Map.size literals
            put st { stringLiterals = Map.insert s idx literals }
            -- Declare string literal at top level
            let decl = "static const char* str_" ++ show idx ++ " = " ++ show s ++ ";"
            modify $ \st' -> st' { generatedDecls = decl : generatedDecls st' }
            return $ "str_" ++ show idx

genExpr (EList exprs) = do
    -- Generate list construction
    resultVar <- freshVar "list"
    if null exprs
        then do
            emit $ "    List* " ++ resultVar ++ " = nil();"
            return resultVar
        else do
            elemVars <- mapM genExpr exprs
            emit $ "    List* " ++ resultVar ++ " = nil();"
            -- Build list in reverse
            forM_ (reverse elemVars) $ \elemVar -> do
                tempVar <- freshVar "temp"
                emit $ "    void* " ++ tempVar ++ " = (void*)(intptr_t)" ++ elemVar ++ ";"
                emit $ "    " ++ resultVar ++ " = cons(" ++ tempVar ++ ", " ++ resultVar ++ ");"
            return resultVar

genExpr (ETuple exprs) = do
    -- For simplicity, tuples are arrays
    elemVars <- mapM genExpr exprs
    resultVar <- freshVar "tuple"
    emit $ "    int " ++ resultVar ++ "[] = {" ++ intercalate ", " elemVars ++ "};"
    return resultVar

genExpr (EIf cond thenE elseE) = do
    condVar <- genExpr cond
    resultVar <- freshVar "if_result"
    emit $ "    int " ++ resultVar ++ ";"
    emit $ "    if (" ++ condVar ++ ") {"
    
    thenVar <- genExpr thenE
    emit $ "        " ++ resultVar ++ " = " ++ thenVar ++ ";"
    emit $ "    } else {"
    
    elseVar <- genExpr elseE
    emit $ "        " ++ resultVar ++ " = " ++ elseVar ++ ";"
    emit $ "    }"
    
    return resultVar

genExpr (ELet bindings body) = do
    -- Save current bindings
    savedBindings <- gets varBindings
    
    -- Process let bindings
    mapM_ genLetBinding bindings
    
    -- Generate body
    resultVar <- genExpr body
    
    -- Restore bindings (simplified scope handling)
    modify $ \st -> st { varBindings = savedBindings }
    
    return resultVar

genExpr (ELambda patterns body) = do
    -- For now, lambdas are not supported in C output
    -- Would need to generate function pointers or closure structures
    emit "    // Lambda expression (not yet implemented)"
    return "0"

genExpr (EApp func arg) = do
    funcVar <- genExpr func
    argVar <- genExpr arg
    resultVar <- freshVar "app_result"
    emit $ "    int " ++ resultVar ++ " = " ++ funcVar ++ "(" ++ argVar ++ ");"
    return resultVar

genExpr (EBinOp op left right) = do
    leftVar <- genExpr left
    rightVar <- genExpr right
    resultVar <- freshVar "binop"
    let cOp = case op of
            "+" -> "+"
            "-" -> "-"
            "*" -> "*"
            "/" -> "/"
            "==" -> "=="
            "/=" -> "!="
            "<" -> "<"
            ">" -> ">"
            "<=" -> "<="
            ">=" -> ">="
            "&&" -> "&&"
            "||" -> "||"
            _ -> "+"  -- Default
    emit $ "    int " ++ resultVar ++ " = " ++ leftVar ++ " " ++ cOp ++ " " ++ rightVar ++ ";"
    return resultVar

genExpr (ECase isLinear scrutinee branches) = do
    scrutVar <- genExpr scrutinee
    resultVar <- freshVar "case_result"
    emit $ "    int " ++ resultVar ++ ";"
    
    -- For now, simple if-else chain
    -- Full implementation would need proper pattern matching
    emit "    // Case expression (simplified)"
    emit $ "    " ++ resultVar ++ " = 0; // TODO: implement case"
    
    return resultVar

genExpr (ERecord fields) = do
    -- Records as structs (simplified)
    emit "    // Record expression (not yet implemented)"
    return "0"

genExpr (ERecordUpdate name fields) = do
    emit "    // Record update (not yet implemented)"
    return "0"

genExpr (EFieldAccess expr field) = do
    emit "    // Field access (not yet implemented)"
    return "0"

genExpr (EParens expr) = genExpr expr

-- Generate let binding
genLetBinding :: LetBinding -> CodeGen ()
genLetBinding (LetAnnotation name typ) = do
    -- Annotations are already handled
    return ()

genLetBinding (LetDef name [] expr) = do
    -- Variable binding
    exprVar <- genExpr expr
    cName <- freshVar (sanitizeName name)
    emit $ "    int " ++ cName ++ " = " ++ exprVar ++ ";"
    bindVar name cName

genLetBinding (LetDef name patterns expr) = do
    -- Function binding - emit as nested function (GCC extension) or skip
    emit $ "    // Function binding: " ++ name

genLetBinding (LetDestructure pattern expr) = do
    exprVar <- genExpr expr
    -- Simplified - just bind to variable
    case pattern of
        PVar name -> do
            cName <- freshVar (sanitizeName name)
            emit $ "    int " ++ cName ++ " = " ++ exprVar ++ ";"
            bindVar name cName
        _ -> return ()

-- Write generated C code to file
compileToCFile :: CompileOptions -> Module -> IO ()
compileToCFile opts mod = do
    let cCode = generateC mod
    writeFile (optOutputFile opts) cCode
    putStrLn $ "Generated C code written to: " ++ optOutputFile opts